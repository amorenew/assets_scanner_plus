import 'dart:async';
import 'dart:io';

import 'package:build/build.dart';
import 'package:glob/glob.dart';
import 'package:path/path.dart' as p;
import 'package:yaml/yaml.dart';

class _AssetsScannerOptions {
  const _AssetsScannerOptions._({
    this.path = 'lib',
    this.className = 'R',
    this.fileName = 'r.dart',
    this.ignoreComment = false,
  });

  factory _AssetsScannerOptions() => const _AssetsScannerOptions._();

  factory _AssetsScannerOptions.fromYamlMap(YamlMap map) {
    return _AssetsScannerOptions._(
      path: map['path'] as String? ?? 'lib',
      className: map['className'] as String? ?? 'R',
      fileName: map['fileName'] as String? ?? 'r.dart',
      ignoreComment: map['ignoreComment'] as bool? ?? false,
    );
  }

  /// The path where the `r.dart` file locate. Note that the `path` should be
  /// sub-path of `lib/`.
  final String path;

  /// The class name of the `r.dart`.
  final String className;

  /// The file name of the generated file.
  final String fileName;

  /// Indicate the comments need to be generated or not. Note that the you can't
  /// preview the images assets if `ignoreComment` is `true`.
  final bool ignoreComment;

  @override
  String toString() =>
      '_AssetsScannerOptions(path: $path, className: $className, fileName: $fileName, ignoreComment: $ignoreComment)';
}

/// File header of generated file.
const String rFileHeader =
    '/// GENERATED BY assets_scanner_plus. DO NOT MODIFY BY HAND.\n'
    '/// See more detail on https://github.com/amorenew/assets_scanner_plus.';

/// Ignore for file definition.
const ignoreForFile = '// ignore_for_file: '
    'always_put_control_body_on_new_line,'
    'always_specify_types,'
    'annotate_overrides,'
    'avoid_annotating_with_dynamic,'
    'avoid_as,'
    'avoid_catches_without_on_clauses,'
    'avoid_returning_this,'
    'lines_longer_than_80_chars,'
    'omit_local_variable_types,'
    'prefer_expression_function_bodies,'
    'sort_constructors_first,'
    'test_types_in_equals,'
    'unnecessary_const,'
    'unnecessary_new,'
    'public_member_api_docs,'
    'constant_identifier_names,'
    'prefer_double_quotes';

/// Borrow from https://github.com/dart-lang/sdk/blob/c3f96e863ff402be32aa7acf51ee05b7de0b9841/pkg/analyzer/lib/src/lint/util.dart#L15
final _identifier = RegExp(r'^([(_|$)a-zA-Z]+([_a-zA-Z0-9])*)$');
final _identifierStart = RegExp(r'^([(_|$)a-zA-Z]+)');
final _invalidIdentifierCharacters = RegExp(r'[^_a-zA-Z0-9]+');
const _propertyNamePrefix = 'r_';

/// [AssetsBuilder] will get the assets path from `pubspec.yaml` and generate
/// a `r.dart` with `const` properties of assets path by default. You can custom
/// it by adding an `assets_scanner_plus_options.yaml` file, and the supported key
/// is same with [_AssetsScannerOptions]'s properties name.
class AssetsBuilder extends Builder {
  /// The options for the assets scanner YAML.
  late final _AssetsScannerOptions options = _loadOptions();

  @override
  Map<String, List<String>> get buildExtensions {
    var extensions = options.fileName;
    if (!extensions.endsWith('.dart')) {
      extensions = '$extensions.dart';
    }
    if (options.path != 'lib' && options.path.startsWith('lib/')) {
      extensions = '${options.path.replaceFirst('lib/', '')}/$extensions';
    }
    // TODO: It's so wired that this works, but the `buildExtensions` here not
    // match the `build_extensions` in the `build.yaml` file. Need more research see
    // if it's a correct way.
    return {
      r'$lib$': ['$extensions']
    };
  }

  @override
  Future<void> build(BuildStep buildStep) async {
    final pubspecYamlMap = await _loadPubspecYamlMap(buildStep);
    if (pubspecYamlMap?.isEmpty ?? true) return;

    if (!options.path.startsWith('lib')) {
      log.severe(
        'The path `${options.path}` in `assets_scanner_plus_options.yaml` should be sub-path of `lib/`',
      );
    }

    final outputId = AssetId(
      buildStep.inputId.package,
      p.join(options.path, options.fileName),
    );

    final rFileContent =
        await _generateRFileContent(buildStep, pubspecYamlMap!, options);

    if (rFileContent.isNotEmpty) {
      await buildStep.writeAsString(outputId, rFileContent);
    }
  }

  Future<String> _generateRFileContent(BuildStep buildStep,
      YamlMap pubspecYamlMap, _AssetsScannerOptions options) async {
    final assetPathsClass =
        await _createRClass(pubspecYamlMap, buildStep, options);
    final packageAssetPathsClass = _createPackageAssetsClass(pubspecYamlMap);

    if (assetPathsClass.isEmpty && packageAssetPathsClass.isEmpty) {
      return '';
    }

    final rFileContent = StringBuffer()
      ..writeln(rFileHeader)
      ..writeln(assetPathsClass);
    if (packageAssetPathsClass.isNotEmpty) {
      rFileContent.writeln(packageAssetPathsClass);
    }

    return rFileContent.toString();
  }

  String _createPropertyName(String assetPath) {
    var propertyName = assetPath;
    if (propertyName.startsWith('assets/')) {
      propertyName = propertyName.substring('assets/'.length);
    }

    final extension = p.extension(assetPath);
    if (extension.isNotEmpty) {
      propertyName =
          propertyName.substring(0, propertyName.length - extension.length);
    }

    // On iOS it will create a .DS_Store file in assets folder which will
    // cause an empty property name, so we skip it.
    if (propertyName.isEmpty) return propertyName;

    if (!_identifier.hasMatch(propertyName)) {
      propertyName = propertyName.replaceAllMapped(
        _invalidIdentifierCharacters,
        (match) => '_',
      );
      if (!_identifierStart.hasMatch(propertyName)) {
        propertyName = _propertyNamePrefix + propertyName;
      }
    }

    return propertyName;
  }

  Future<String> _createRClass(YamlMap pubspecYamlMap, BuildStep buildStep,
      _AssetsScannerOptions options) async {
    var assetPaths =
        await _findAssetIdPathsFromFlutterAssetsList(buildStep, pubspecYamlMap);

    // remove .DS_Store files which is autogenerated by macOS
    assetPaths = assetPaths
        .where((asset) => !asset.toLowerCase().endsWith('.ds_store'))
        .toList()
      ..sort();

    if (assetPaths.isEmpty) {
      return '';
    }

    final assetPathsClass = StringBuffer()
      ..writeln('class ${options.className} {')
      ..writeln('  static const package = \'${buildStep.inputId.package}\';')
      ..writeln();

    final propertyNames = <String, int>{};
    for (final assetPath in assetPaths) {
      final propertyName = _createPropertyName(assetPath);
      if (propertyName.isNotEmpty) {
        propertyNames.update(propertyName, (value) => value + 1,
            ifAbsent: () => 1);
      }
    }

    for (final assetPath in assetPaths) {
      var propertyName = _createPropertyName(assetPath);
      if (propertyName.isNotEmpty) {
        final count = propertyNames[propertyName]!;
        if (count > 1) {
          final extension = p.extension(assetPath).replaceAll('.', '_');
          propertyName = '$propertyName$extension';
        }

        if (!options.ignoreComment) {
          assetPathsClass.writeln('  /// ![](${p.absolute(assetPath)})');
        }
        assetPathsClass
          ..writeln('  static const $propertyName = \'$assetPath\';')
          ..writeln();
      }
    }

    assetPathsClass.writeln('  static const allSVGAssets = [');
    final svgs = assetPaths
        .where((assetPath) => assetPath.endsWith('.svg'))
        .toList()
      ..sort();

    for (final assetPath in svgs) {
      var propertyName = _createPropertyName(assetPath);
      if (propertyName.isNotEmpty) {
        final count = propertyNames[propertyName]!;
        if (count > 1) {
          final extension = p.extension(assetPath).replaceAll('.', '_');
          propertyName = '$propertyName$extension';
        }
        assetPathsClass..writeln('    $propertyName,');
      }
    }

    assetPathsClass
      ..writeln('  ];')
      ..writeln()
      ..writeln(ignoreForFile)
      ..writeln('}');

    return assetPathsClass.toString().trim();
  }

  String _createPackageAssetsClass(YamlMap pubspecYamlMap) {
    final assetPaths = _getAssetsListFromPubspec(pubspecYamlMap);
    final packageAssetPaths = <String, Map<String, String>>{};

    for (final assetPath in assetPaths) {
      // Handle the package assets, more detail about the directory structure:
      // https://flutter.dev/docs/development/ui/assets-and-images#bundling-of-package-assets
      if (assetPath.startsWith('packages')) {
        final segments = assetPath.split('/');
        if (segments.length >= 3) {
          final packageName = segments[1];
          final assetPathsOfPackage =
              packageAssetPaths.putIfAbsent(packageName, () => {});
          // The length of `packages/<package-name>/`
          final actualAssetPath = segments.sublist(2).join('/');
          final propertyName = actualAssetPath
              .substring(0, actualAssetPath.lastIndexOf('.'))
              .replaceAll('/', '_');
          assetPathsOfPackage[propertyName] = actualAssetPath;
        }
      }
    }

    if (packageAssetPaths.isEmpty) {
      return '';
    }

    final packageAssetPathsClass = StringBuffer();
    final pubspecDependencies = _getPackagesFromPubspec(pubspecYamlMap);

    packageAssetPaths.forEach((packageName, assetPaths) {
      if (!pubspecDependencies.contains(packageName)) return;

      final className = packageName
          .split('_')
          .map((part) => '${part[0].toUpperCase()}${part.substring(1)}')
          .join('');
      packageAssetPathsClass
        ..writeln('class $className {')
        ..writeln('  static const package = \'$packageName\';');
      assetPaths.forEach((propertyName, assetPath) {
        packageAssetPathsClass
            .writeln('  static const $propertyName = \'$assetPath\';');
      });
      packageAssetPathsClass
        ..writeln(ignoreForFile)
        ..writeln('}');
    });

    return packageAssetPathsClass.toString();
  }

  Future<YamlMap?> _loadPubspecYamlMap(BuildStep buildStep) async {
    final pubspecAssetId = AssetId(buildStep.inputId.package, 'pubspec.yaml');
    if (!await buildStep.canRead(pubspecAssetId)) {
      return null;
    }
    final content = await buildStep.readAsString(pubspecAssetId);
    return loadYaml(content) as YamlMap;
  }

  Future<List<String>> _findAssetIdPathsFromFlutterAssetsList(
      BuildStep buildStep, YamlMap pubspecYamlMap) async {
    final assets = _getAssetsListFromPubspec(pubspecYamlMap);
    final result = <String>{};
    for (final asset in assets) {
      if (asset.endsWith('/')) {
        final glob = Glob('$asset*');
        await for (final id in buildStep.findAssets(glob)) {
          result.add(id.path);
        }
      } else {
        if (await buildStep
            .canRead(AssetId(buildStep.inputId.package, asset))) {
          result.add(asset);
        }
      }
    }
    return result.toList();
  }

  List<String> _getAssetsListFromPubspec(YamlMap pubspecYamlMap) {
    final flutterMap = pubspecYamlMap['flutter'] as YamlMap?;
    if (flutterMap == null) {
      return [];
    }
    final assets = flutterMap['assets'] as YamlList?;
    if (assets == null) {
      return [];
    }
    return assets.map((e) => e.toString()).toList();
  }

  List<String> _getPackagesFromPubspec(YamlMap pubspecYamlMap) {
    final dependencies = pubspecYamlMap['dependencies'] as YamlMap?;
    if (dependencies == null) {
      return [];
    }
    return dependencies.keys.cast<String>().toList();
  }

  _AssetsScannerOptions _loadOptions() {
    try {
      final file = File('assets_scanner_plus_options.yaml');
      if (file.existsSync()) {
        final yaml = loadYaml(file.readAsStringSync()) as YamlMap;
        return _AssetsScannerOptions.fromYamlMap(yaml);
      }
    } catch (e) {
      log.warning(
          'Failed to load `assets_scanner_plus_options.yaml` file, fallback to default options.');
    }
    return _AssetsScannerOptions();
  }
}
